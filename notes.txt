_______________________________22st_of_October____________________________________

In order to choose fro any sorting algorithms, first went into Time Complexity,
in order to understand which algorithms areactually efficient, and how to
determine it performance.

Time Complexity of an algorithm isn't equal to the actual time required to
execute a particular code, but the number of times a statement executes
-----
Big O notation - powerful tool used in computer science to describe the time
complexity of algorithms. Used to compare the efficiency of different
algorithms and to predict how they will behave as the input size increases.
-----
Time Complexity - considers how many times each statement executes

Different Types Of Time Complexity:

__Linear: O(n), every time, a liear amount of time is required to execute code

__Logarithmic: O(log n), the running time of an algorithm is proportional to the
logarithm of the input size (e.g Binary Search Algorithm)

__Quadratic: O(n^2), running time of an algorithm is proportional to the square
of the input size (e.g Bubble Sort Algorithm)

__Cubic: O(n^3), running time is proportional to the cube of the input size
(e.g Matrix Multipliation Algorithm)

__Exponential: O(2^n), running time of an algorithm doubles with each addition
to the input data set
=================================================================================
Sorting algorithms can be broadly categorised into comparison-based and
non-comparison-based methods. 

Selection, Bubble, Insertion and Heap sorts are all examples of the algorithms
that uses constant space for producing the output (modifies the given array only)

_______________________________23rd_of_October____________________________________

Need to figure out the plan: So I have ---

1. Find and figure out the best sorting algorithm to used.
2. Figure out the way arguments are parsed, on which cases to look.
3. 
4. Write function for each operation mentioned in the subject.

Parsing of arguments, so one of requirements of the subject, is check arguments,
and numbers in general if they have duplicates, if they has we print error and
don't process anything

So, this point solely depends on two while loops, we take the first number,
and check it with every single number after the one we took.
For example, we take the numebr on position i = 0, we check it with the number
on position j = i + 1, so 1, if they are the same, do error function, if not
increment j, incremment it untill j = size of stack a, If this is a case.

_______________________________27th_of_October____________________________________

So, what our main function function should look like is validate the arguments,
we have to make sure that our numbers don't have any letters and no pluses and
minuses without numbers after

_______________________________28th_of_October____________________________________
Want to finish push_swap before halloween, I think it's very good.

Gonna finish all validating and parsing today so I can come to algorithms next day

Validation should be good, needs to check somewhere also if the numbers are not
bigger than integer data type

So, eventually we have two possible inpit styles:
___Multiple Arguments - 3 2 -5 10
___One big String - "3 2 -5 10"

So, there is an option of joining multiple arguments in one string, split it by
spaces into double array, count how many numbers in total are there.
Then, while index lower than  the count, we convert each string stored in temp,
and then coresspondly store them inside of the stack_a

What I'm thinking about is the difference between atoi and atol, and do I need to
use atol, or atoi would be enough

We can't use atoi because, we can't check if the number is valid(in the int range)
before actually converting it to int. So, we use atol, that converts the string
into long integer making sure that it fits inside, and no overflow happens. only
after converting, we check, and then if it's bigger exit, and print ERROR to
terminal.

_______________________________29th_of_October____________________________________
Would be very good if I finish writing operations today.
So there are 3 different types of operations:
__Push - pa & pb
__Swap - sa & sb && ss
__Rotate - ra & rb & rr & rra & rrb & rrr

I need to write this functions, I'm not able to finish it today, I think.

_______________________________30th_of_October____________________________________
Doing operations, finish them today for sure

pa - take the first element at the top of b and put it at the top of a

dest_temp[i] = src_temp[i]
i++;

1 STEP
i = 0;
arr->a[i] + 1 = arr->a[i]
i++;

i = size->a = 3
while (3 > 0)
{
	arr->a[3 + 1] = arr->a[3] - there is no number at index 3, because
  |	0  |  1  |  2 |
  |	34 | 940 | 12 |
}
so we do like this 
while (3-- > 0)
{
	arr->a[2 + 1] = arr->[2]; - decrementing i in advance
}

2 STEP
The expession above represents the situation of moving the blocks of data in the
stack_a downwards by 1.
Tne first element of stack_a by index [0] moving to the position of index [1]
The second element of stack_a by index [1] moving to the position of index [2]
Thereby, we have an open position at index [0].

3 STEP
Incremented the size of stack a, stored the first block of stack_b inside of 
the stack_a at the first position. Decremented the size of stack_b by one

4 STEP
Move stack_b upwards by 1. So, the second elemnt [1] of stack_b becomes the
first one [0].
--------------------------------------------------------------------------------

dest_temp[i] = src_temp[i]
i++;

i = 0;
arr->b[i] = arr->b[i] + 1
i++;

pb - take the first element at the top of a and put it at the top of b

Pretty much the same logic, actually the same logic, just reversed stacks, 
shift stack_b by 1 downwards, put first element from stack_a to stack_b,
increment the size of stack_b, decrement the size of stack_a, shift all
elements of stack_a by 1 upwards. 
---------------------------------------------------------------------------------

Rotate file is theriotically should include 6 functions itself, but it's not
possible by the norminette rules. We would need to put one rotate function 
somewhere OR do separate files for rotate fucntions and reverse rotate functions.

ra - Shift up all elements of stack a by 1
The first element[0] becomes the last one[size_a - 1] of stack_a

	while (i < arr->size_a)
	{
		arr->a[i] = arr->a[i + 1];
		i++;
	}

i = 0; & size_a = 3;

  |	0  |  1  |  2 |
  |	34 | 940 | 12 |

while (i < 3)
{
	arr->a[0] = arr->a[1]; i = 0;
	arr->a[1] = arr->a[2]; i = 1;
	arr->a[2] = arr->a[3]; i = 2;
}

while (i < 3 - 1)
{
	arr->a[0] = arr->a[1]; i = 0;
	arr->a[1] = arr->a[2]; i = 1;
	arr->a[2] = arr->a[3]; i = 2; - we can't use this one already
}
---------------------------------------------------------------------------------

Such a beatiful files I'm writing. The last operation to write before dinner is 
reverse rotation

rra -  Shift down all elements of stack a by 1. 
The last element[size_a - 1] becomes the first one[0] of stack_a

1 STEP
Store the last element of the stack in temporary int value

2 STEP
So, we need to do so that the first element[0] became the second one[1]
The second element[1] became the third one[2]

i = arr->size_a;
while (i-- > 0)
{
	arr->a[i + 1] = arr->a[i];
}

size_a = 3;
i = 3 - 2 = 1;

  |	0  |  1  |  2 |
  |	34 | 940 | 12 |

temp = 12;

while (2 => 0)
{
	arr->a[2] = arr->a[1]; i = 1;
	arr->a[1] = arr->a[0]; i = 0;
	i--;
}

I have done all operations, it was quite complicated.

###############################___NEW_CHAPTER___##################################

Sorting Algoritms

I think I would just do simple sort for 3 numbers, bubble sort for 5 numbers,
some sort for 100, and some for 500.

Returning Values are the operations one by one outputed in the command line:

Return 'n' size of instructions for sorting 'x' number of values:

__If x = 3 then n <= 3
__If x = 5 then n <= 12
__If x = 100 then n < 1500
__If x = 500 then n < 11500

Comparison Based							Non_Comparison Based
Bubble Sort	O(n^2)								Counting Sort
Insertion Sort									Radix Sort
Selection Sort
Quick Sort
Merge Sort
Heap Sort

_______________________________31th_of_October____________________________________
Haven't done anything, was busy with exam preparation

_______________________________1st_of_November____________________________________
Didn't come to university

_______________________________2nd_of_November____________________________________
Came not for a long time. Want to finish bubble sort, ran multiple tests, make
sure that I'm covering all the validation tests. I don't want to stop the process
of making push swap, I would do a lot of preparation for exam but still do some
sorting. Plan for the rest of the day to do a bubble sort

Turns out that it's not that easy, sa - swaps only hte first two values, and it
can jump to the end and sort to other values

2, 1, 3, 6, 5, 8

Let's just implement turk sorting algorithm right away:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STEP 1. for example, size_a = 6, i = 0, 6 - 3 = 3  0 - 5 | 0 - 2
while (i < 3)
{
	0 i = 0;
	1 i = 1
	2 i = 2
}
---> blidly push every value from stack_a to stack_b until there are only 3
numbers left in stack_a

STEP 2. Sort stack_a's three numbers using the sort_three function

STEP 3. 

Solved the problem with range thing 

------------------------------3-RANDOM-NUMBERS------------------------------------

1, 3, 2 --> 2, 1, 3 --> 1, 2, 3
(rra - last element becomes the first one, sa - swap first two elements)
i = 1
j = 3
z = 2
----> j > i && j > z && i < z

2, 1, 3 --> 1, 2, 3
(sa - swap first two elements)
i = 2
j = 1
z = 3
----> i > j && z > i && j < z

2, 3, 1 --> 1, 2, 3
(rra - last element becomes the first one)
i = 2
j = 3 
z = 1
----> z < i && z < j && i < j

3, 1, 2 --> 1, 2, 3
(ra - first element becomes the last one)
i = 3
j = 1
z = 2
----> i > j && i > z && j < z

3, 2, 1 --> 2, 1, 3 --> 1, 2, 3
(ra - first element becomes last one, sa - swap first two elements)
i = 3
j = 2
z = 1
----> i > j && j > z

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@__EXPERIMENT__@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

2, 1, 3, 6, 5, 8
sa
1, 2, 3, 6, 5, 8
sa
1, 2, 3, 5, 6, 8

5, 4, 3, 2, 1
10 operations

_______________________________8th_of_November____________________________________

Come back to push swap, have made excellent progress in exam preparation. Right now,
I need to do a sorting algorithm to finish with push swap.

QuickSort Algorithm - works on the principle of divide and conquer, breaking down
the problem into smaller sub-problems.

___STEP 1. Choose a Pivot
Select an element from the array as the pivot(first element, last element, median,
random element)

___STEP 2. Partition The array
All elements smaller than the pivot move to the stack_b
All elements greater than the pivot will stay in stack_a

Taking the pivot, putting all possible smaller numbers in stack b, while stack_a
doesn't have three numbers left in it.

The key function in quick sort is a partition. The target of partitions.

I don't know, I'm not gonna rush, want really understand push swap, and If i
need time, i'm gonna spend it for making push swap. See you tomorrow.

_______________________________10th_of_November____________________________________

Victoria does the sorting at first to find the number that located excatly at the
middle of the stack.

Divide and Conquer Paradigm involves three steps at each level of recursion:

__Divide the problem into a number of subproblems

__Conquer the subproblems by solving them recursively. If the subproblem sizes
are small enough solve them in straightforward manner.

__Combine the solutions to the subproblems into the solution for the original
problem

So, finally I'm gonna use quick sort finding a median to sort the numbers

5 4 3 2 1

a - 3 2 1
b - 4 5

a  - 1 2 3
5 4 1 2 3
sa
ra
ra

_______________________________11th_of_November____________________________________

Time to write notes again. So, the plan for today was to start writing the sorting
algorithm.

The first step is to determine the pivot of the stack

1, 2, 3, 4, 5, 6 - size = 6
1, 2, 3, 4, 5, 6, 7 - size = 7

if (size % 2 != 0) - means that the size is odd
	median = array[((n - 1) / 2)];
7 - 1 = 6
6 / 2 = 3

0 -> 1 -> 2 -> 3

Successfuly determined the pivot, now there are lickely two sorting function, one
for stack a and another for stack b. Moreover, the thing to be careful with is
that the function for sorting stack b, should be reversed to the function that
sorts stack a.

_______________________________22nd_of_November____________________________________

It's been exactly one month since I started the push swap project

WOW

I need to do the sorthing algorithm. 

_______________________________24th_of_November____________________________________

Radix Definition

Radix(base) - the number of unique digits, including the digit zero, used to
represent the numbers. Eg.: for the decimal system the radix is ten, because it uses
the ten digits from 0 through 9.

In radix sort, each step requires just a single pass over the data, since each item
can be placed in its busket without comparison with any other element.

2 - 001 0
1 - 000 1
3 - 001 1
6 - 011 0
5 - 010 1
8 - 100 0

2 - 00 1 0
6 - 01 1 0
8 - 10 0 0
1 - 00 0 1
3 - 00 1 1
5 - 01 0 1

8 - 1 0 0 0
1 - 0 0 0 1
5 - 0 1 0 1
2 - 0 0 1 0
6 - 0 1 1 0
3 - 0 0 1 1

1 - 0 0 0 1
2 - 0 0 1 0
3 - 0 0 1 1
5 - 0 1 0 1
6 - 0 1 1 0
8 - 1 0 0 0

_______________________________25th_of_November____________________________________

Binary LSD Radix Sort - uses the least significant digit (the rightmost bit) to
sort data, and then goes to the next nost significant digit, repeating the
stable sort process until the most significant bit is sorted

TIme Complexity is O(w * n), where n is the number of items and w is the number 
of bits.

Radix Sort uses a counting sort as a subroutine to sort

I need to sort the copy of the array, and base on this sorted array, assign to
values the specific index.

j = 0;
while (stack_a hasn't finished)
{
	i = 0;
	while (arr->a[j] != c[i])
		i++;
}
c is a sorted arraya 
a is unsorted array

a --> 2, 1, 3, 6, 5, 8
c --> 1, 2, 3, 5, 6, 8

a[0] = 2  i = 0; j = 0;
c[0] = 1
i++;
a[0] = 2  i = 1; j = 0;
c[1] = 2

1, 
j++;
a[1] = 1  i = 0; j = 1;
c[0] = 1

1, 0, 
j++;
a[2] = 3  i = 0; j = 2;
c[0] = 1
i++;
a[2] = 3  i = 1; j = 2;
c[1] = 2
i++;

Finding the indexes currently, need to push it to the existence stack.

I have prepared everything to implement radix sort.

For 500 numbers -- 6784 operations
For 100 numbers -- 1084 operations

So, there is some possible improvement. Nice and big improvement, what my program
does right now. Is that it looks if the current bit is 0, if yes, pushes it to 
stack b, otherwise rotates stack a. 

What the improvement version does is that it looks if the current bit is 0, if yes, pushes it to 
stack b, otherwise rotates stack a. Then it goes to the radix sort for stack b
